== About WSGI ==

modu is based around Python's WSGI protocol. WSGI was created ostensibly to provide a familiar but standardized way to create Python web applications. Although it is widely used, it is not without its flaws, in specification and often in implementation of the frameworks that implement it. Some of these issues are outlined at the following URLs:

    * http://www.b-list.org/weblog/2009/aug/10/wsgi
    * http://lucumr.pocoo.org/2009/7/30/nih-in-the-wsgi-world
    * http://lucumr.pocoo.org/2009/8/5/pro-cons-about-werkzeug-webob-and-django

However, it does provide a generally well-documented interface for dealing with web applications, and is generally well accepted by the community.

There are a few caveats that should be understood when dealing with modu, and its particular implementation of WSGI. During the development of the modu codebase, great care was taken to follow the spec, but there are still likely some derivations and issues. The reality of implementing WSGI properly is that there are a number of small differences between different apps and host environments that must be accounted for.
    
    * The `Request` object that is passed around a modu web app is a
      subclass of the Python `dict` object, which provides additional functionality, but does not interfere with the usual WSGI environment variables. Therefore it is possible to run other WSGI applications through a shim `Resource` in modu, which then passes the same `Request` object as the `environ` to the WSGI application object.
    
    * modu has been tested (and is used extensively in production)
      with the mod_wsgi plugin for Apache 2.2 and later. So far it has only been used with the prefork MPM, but it should support the threaded (worker) MPM as well.
    
    * The current built-in webserver is based on Twisted Web, but does
      not yet use the existing Twisted Web WSGI support. The `modu-web` '''twistd''' service implements its own WSGI environment with additional features helpful when debugging modu applications.

== The Site object ==
Every modu application is configured by creating a `Site` class that can be discovered by modu at request time. A very basic `Site` class might look something like this:

{{{
#!python
class Site(object):
    classProvides(plugin.IPlugin, app.ISite)
    
    def initialize(self, application):
        application.base_domain = 'localhost'
        application.base_path = '/modu'
        application.activate('/', index.Resource)
}}}

The `initialize()` method is called the first time a URL for a particular site is loaded.

== The Application object ==

A newly instantiated `Application` object is passed to `Site::initialize()`, where we can set any static site configuration variable needed. A number of standard config variables exist, but projects can create new ones as desired.

One an application object is created, it is immutable for the lifetime of the server process it's running under. When unit testing, `Application::make_immutable()` is often omitted as a convenience by those who know what they're doing.

    '''base_domain'''::
    Default: `'localhost'`::
        The base domain is the domain that this application will be loaded for.

    '''base_path'''::
    Default: `'/'`::
        The base path is where the root modu resource is located.

    '''db_url'''::
    Default: `'MySQLdb://modu:modu@localhost/modu'`::
        A specially constructed URL representing the database connection details.

    '''session_class'''::
    Default: `session.DbUserSession`::
        The default session class. Set to None to disable sessions.

    '''session_cookie_params'''::
    Default: `{'Path':'/'}`::
        The default paramaters for the created session cookie.

    '''initialize_store'''::
    Default: `True`::
        Should a store object be created by default?

    '''webroot'''::
    Default: `'webroot'`::
        If a path is not found within the URL Tree (i.e., there is no Resource at a given URL), the path is translated to the webroot, which, if a relative path, is appended to the application's `approot`.

    '''debug_session'''::
    Default: `False`::
        If True, display debug information when a session is loaded or saved.

    '''debug_store'''::
    Default: `False`::
        If True, display queries when objects are loaded or saved.

    '''enable_anonymous_users'''::
    Default: `True`::
        If the current req.user is not a logged-in user, create an AnonymousUser instance instead of using None

    '''disable_session_users'''::
    Default: `False`::
        If True, don't login users based on their session information.

    '''disable_message_queue'''::
    Default: `False`::
        If True, disable creation of the session-based message queue.

    '''magic_mime_file'''::
    Default: `None`::
        If defined, specify an additional location for the magic mime file. For example, on Mac OS X with Apache 2, this should be set to `/etc/apache2/mime.types`

    '''tree'''::
        The URL tree that is populated by the Site class

    '''site'''::
        The Site class used to create this Application

Apart from configuration variables, the application object also manages the `URLNode` tree of resources that make up your site. A new resource is added by providing the path, a `Resource` class and any arguments to `Application::activate()`, usually from inside a `Site::initialize()` method.

{{{
#!python
def initialize(self, application):
    # ...other configuration code here
    application.activate('/', index.Resource)
    application.activate('/pages', page.Resource, 'example.com')
    application.activate('/admin', resource.AdminResource,
        default_path    = 'admin/listing/page', 
        itemdef_module  = myproject.itemdefs
    )
}}}

In this example, a request for http://example.com/admin would instantiate the `AdminResource` class with the provided `default_path` and `itemdef_module` keyword arguments. We'll talk more about the admin resource later on.

A nice side-effect of instantiating resources at request time is that you can feel free to use member attributes to hold references to data during the content generation process. Since the object will be disposed of after the request is over, you're safe from influencing any other requests.

== The Request object ==

A single `Request` object is created as a representation of an HTTP request, and is passed around a modu application through the lifetime of a request. It contains a series of environment variables describing the current request, and also holds on to a number of modu-specific variables, as well as outgoing headers for the HTTP response.

First and foremost, Request objects hold the key-value pairs supplied by the WSGI environment. These are basically similar to the variables defined by the CGI standard:

    || REQUEST_METHOD  ||  CONTENT_LENGTH  ||
    || SCRIPT_NAME     ||  SERVER_NAME     ||
    || PATH_INFO       ||  SERVER_PORT     ||
    || QUERY_STRING    ||  SERVER_PROTOCOL ||
    || CONTENT_TYPE    ||  HTTP_*          ||

The last item (HTTP_*) represents the standard HTTP headers such as HTTP_CONTENT_LENGTH and others.

Also included are the WSGI-specific variables such as:

    || wsgi.version    ||  wsgi.multithread   ||
    || wsgi.url_scheme ||  wsgi.multiprocess  ||
    || wsgi.input      ||  wsgi.run_once      ||
    || wsgi.errors     ||                     ||

More information on these variables can be found in the WSGI spec:

    http://www.python.org/dev/peps/pep-0333

Finally, a number of modu-specific variables are created:

    '''modu.app'''::
        The current `Application` object, containing the configuration variables for this site/application.

    '''modu.approot'''::
        The main modu application directory. This is dynamically detected as being 2 directory levels above the discovered modu site configuration file.

    '''modu.path'''::
        The URL path *after* the subpath where this application is located; for example, if an application's base path is /myapp, a request to /myapp/root would result in a modu.path of '/root'.

    '''modu.pool'''::
        The default database connection, if available.

    '''modu.store'''::
        The default `Store` object, connected through '''modu.pool'''

    '''modu.session'''::
        The current `Session`, if available.

    '''modu.user'''::
        The current logged-in user, if available. Can also be an `AnonymousUser` object, or `None`.

    '''modu.messages'''::
        An interface to server user messages and errors, saves temporary data in session.

    '''modu.data'''::
        Currently posted form data

    '''modu.content'''::
        An interface for storing HTML header content, allowing modu code to add style sheets or javascript at any time.

All of the modu.* variables can be accessed as attributes on the `Request` object (e.g., req.app, req.store. req.pool). 

Additionally, the `Request` object provides the following attributes:

    '''rsrc'''::
        The currently selected `Resource` object, if available

    '''prepath'''::
        A list of path elements representing consisting of the path TO the current `Resource` within modu; if 'modu.path' is /one/two/three, and the current `Resource` is activated at /one, prepath will be `['one']`

    '''postpath'''::
        A list of path elements representing consisting of the path FROM the current `Resource` within modu; if 'modu.path' is /one/two/three, and the current `Resource` is activated at /one, prepath will be `['two', 'three']`

    '''response_headers'''::
        A list of tuples representing the HTTP response headers to be returned.

=== Error Logging ===

When developing modu applications, users are encouraged to use the built-in, Twisted-based web server to run their applications. In this situation, any number of methods are available for logging to the console (or error log), but it's generally as simple as issuing a 'print' statement.

If you want to log properly in any environment, you'll want to use `Request::log_error()` to make a proper WSGI log line. This method is a convenience function that performs a write (with line-endings) to the stream that's kept in the Request object as 'wsgi.errors' -- remember, modu `Request` objects support all the keys passed in the WSGI environment dictionary.

=== JIT Variables ===

The modu.* variables 'pool', 'store', 'session', 'user', and 'messages' are "Just In Time" variables, and are only populated when first requested.

These variables behave much the same way as regular request variables, but there's one catch. Checking containment of a JIT variable (e.g., `'modu.session' in req`) will not instantiate that variable if it hasn't been used yet, but will still return `True`.

Neither will using `req.get()` instantiate a JIT variable. Only using the `req['modu.session']` or `req.session` syntax will populate the variable on-demand.

== Paths and URLs ==

The primary system of organizing URLs in modu is based around a class called `URLNode`. `URLNode` provides a mechanism for creating a tree of nodes, where each level of nodes has its own name. A node may contain a value or not, and the entire tree may be queried with a particular slash-separated path (e.g., a URI).

Let's look at a sample representation of a very basic `URLNode` tree. To begin with, we'll populate the tree with some objects at various paths:

{{{
#!python
tree = url.URLNode()
tree.register('/one', 1)
tree.register('/one/two', 2)
tree.register('/three', 3)
tree.register('/four', 4)
tree.register('/one/five/six', 6)
}}}

This results in a tree where the nodes have been laid out as follows:

{{{
<root>
+-----/one
+---------/two
+---------/five
+--------------/six
+-----/three
+-----/four
}}}

Requesting any of the paths specified as part of those calls to register() return obvious results, but what happens if we request '/', or '/one/five'?

In this example, there was no object stored at '/', so attempting to parse a URI of simply '/' would return `None` (and in practice would generate a 404 status).

For the second URI, '/one/five', the tree will be searched using a mock-depth-first algorithm. The deepest registered object that satisfies this path will be returned, so in this case, the number 1 would be returned.

What happens to the rest of the path? In this case, the resulting tree analysis also establishes the `pre-` and `postpath` variables. The `prepath` variable becomes `['one']`, while the `postpath` variable becomes `['five']`.

Fetching one last URI of '/one/five/six', however, returns the value 6 and sets `prepath` to `['one', 'five', 'six']`, and `postpath` to the empty list.

=== Host Trees ===

As an implementation detail, modu uses the `URLNode` class to construct a second tree to organize the different modu sites/applications that might exist on a particular machine. Since the discovery process for finding site configs will load any site found in sys.path, a single server can host all of the simultaneously, provided they all use different domains or base paths.

The host tree is basically a dictionary of `URLNode` trees. The keys are  hostnames with appended port numbers, while multiple apps on the same domain are stored under their base_path config attribute. The end result looks something like this pseudocode:

{{{
host_tree = {
    'localhost:8888'    : URLNode(None)[
                            /modu : <class ModuSite>,
                            /trac : <class TracPassthroughSite>,
                        ],
    'example.com:80'    : URLNode(None)[
                            /     : <class ExampleSite>,
                        ],
}
}}}

=== Handling Complex URL Schemes ===

The default implementation of modu paths can be limited in certain respects when you have a pre-existing URL scheme that you must implement. For example, let's say you have a scheme that requires the following URLs:

    * /node/1234
    * /node/1234/edit
    * /node/1234/delete

where 1234 is the node ID. The easiest way to implement this is to register a `Resource` for /node, and allow it to handle all the URLs starting with /node. However, in complex applications this may not be suitable, either from a code organization standpoint or because of a even more complex URL structure.

Another more powerful option is available through the use of Resource Delegates. If you create a `Resource` that implements the `IResourceDelegate` interface, and supply a corresponding `get_delegate()` method, you can write code that examines the request, and then returns some `Resource` (this can be `self`, or any other `Resource`). Here's an example:

{{{
#!python
class Resource(resource.CheetahTemplateResource):
    implements(resource.IResourceDelegate)
    
    def get_delegate(self, req):
        if(req.postpath[1] == 'player'):
            return player.Resource()
        else:
            return self
}}}

In this case, the `Resource` represents an album detail page, at a URL like '/albums/1234'. However, I wanted to be able to popup a media player window through JavaScript, and the easiest way was just to append '/player' to the URL.

There's one small catch with this method. This happens early in the resource lookup process, and you aren't limited to making delegate choices based solely on the URL scheme, so there's no way for modu to automatically update the `pre-` and `postpath` variables. In the example above, my `prepath` is still `['albums']` and my `postpath` is still `['1234', 'player']`, but if that matters to you, you can adjust those variables before returning the delegate.

=== modu Paths ===

A modu application manages a `URLNode` tree of `Resource` objects. It provides an extremely simple mechanism for looking up those resources based on the URL path used in the HTTP request.

Every modu application is setup at some path from the root of the server. The particular path is specified in the site config using the `base_path` attribute. In the default scenario, the base_path is set to '/'.

Once a `Resource` is found for a particular URI, the Request object has its path, prepath, and postpath attributes set for additional processing. This system is specifically aimed towards creating search-friendly 'clean' URLs; adding additional path elements to a linked URI is a great way to 'cleanly' supply GET arguments without using the query string syntax.

The goal when using modu paths is to allow the same codebase to be run over several domains (say, between production and staging, or development sites) without needing to replace config files or doing tricks with symlinks. To further this goal, users are encouraged to use `Request::get_path()` to generate URLs in their templates and resource code.

`get_path()` takes an arbitrary number of path elements, concatenates them together -- removing duplicate slashes, etc -- and creates an absolute URL containing the hostname, port (if necessary), and `base_path` for the particular running site configuration. It's also able to deal with certain Apache proxying situations where the WSGI environment dictionary contains '''HTTP_X_FORWARDED_SERVER'''.

== Resource API ==

Once a resource has been found for the given request, the various methods that make up the content generation process are called in turn.

    '''IResourceDelegate::get_delegate()'''::
        First the resource is examined to see if it is a Resource Delegate. If so, its `get_delegate()` method is called, and the remaining methods in the content generation flow are called on *that* `Resource` instead.

    '''IResource::get_response()'''::
        The top-level `Resource` method is `get_response()`, which is responsible for setting up the response and returning the content.

Technically, a class needs only to implement `get_response()` to function properly as a `Resource`, but is then responsible for taking care of all bookkeeping and content generation.

Most resources are subclasses of `modu.web.resource.Resource`, and so the `get_response()` method is already defined. It calls the following methods:

    '''IResource::get_content_provider()'''::
        Resources are not required to implement `IContent`, but if they do not, they must return an instance of an `IContent` implementor from this method.

    '''IContent::prepare_content()'''::
        Once an `IContent` implementor is found, `prepare_content()` is called to setup whatever instance data is needed to render this content. If `IContent` is also an `ITemplate` implementor, this is where `ITemplate::set_slot()` is called to populate the template dictionary.

    '''IContent::get_content_type()'''::
        For most superclasses, `get_content_type()` is already defined, returning the string 'text/html'. This can be overridden as necessary; for example, returning 'text/html; charset=utf-8' will force UTF-8 encoding in the browser.

    '''IContent::get_content()'''::
        As a final step, return the content that was prepared in `prepare_content()`. The separation of these two functions allows template engines to render the template here, so the particular `Resource` implementation can override `prepare_content()` without clobbering the template compilation.

Finally, there are a few functions that are called for templates. Currently modu only actively supports Cheetah templates, but this is the order used in that case. Ideally alternate template engines would follow a similar flow.

    '''ITemplate::get_template()'''::
        Return some kind of template. In the case of the CheetahTemplate implementation, this can be either a filename (relative to the template dir) or a string containing the template code.

    '''ITemplate::get_template_type()'''::
        Return a description of what the result of `get_template()` is supposed to be. Currently the two options used for Cheetah templates are 'filename' (the default), or 'str' (for inline templates).

    '''ITemplate::get_template_root()'''::
        Only relevant for 'filename' type templates, this function specifies the location of the template directory. The default behavior is to look in 'templates' in the application's `approot`, or to use the `Resource`'s `template_dir` variable, if it exists. This method can be overridden if desired, however.

=== WSGI Passthrough ===

There's one special `Resource` implementation included with modu that may be useful to various applications, and that's the `WSGIPassthroughResource`. If you wish to install a WSGI app under a path on a modu web application, this resource will allow you to manipulate the request environment before sending it to the WSGI app.

Here's an example of embedding the Trac project management app inside a modu Resource:

{{{
#!python
class Resource(resource.WSGIPassthroughResource):
    def __init__(self):
        from trac.web import main
        # provide the WSGI app object as the first argument
        super(Resource, self).__init__(main.dispatch_request)

    def prepare_content(self, req):
        # Depending on the WSGI container we're in, PATH_INFO
        # may or may not have a leading slash
        path_info = req['PATH_INFO']
        if(path_info.startswith('/trac')):
            req['PATH_INFO'] = path_info[5:]
        elif(path_info.startswith('trac')):
            req['PATH_INFO'] = path_info[4:]
    
        req['SCRIPT_NAME'] = '/trac'
    
        # here we trick Trac into using modu authentication
        req['REMOTE_USER'] = 'anonymous'
        if(req.user.get_id() and req.user.is_allowed('access trac')):
            req['REMOTE_USER'] = req.user.username
    
        from trac.web.api import HTTPForbidden
        try:
            super(Resource, self).prepare_content(req)
        except HTTPForbidden, e:
            # you should handle permission denied, etc. errors here.
            pass
}}}

== Templates ==

modu has pretty much standardized on using the Cheetah template system for it's preferred templating engine, so much of the documentation in this section is going to be rather Cheetah-specific.

=== Other Engines ===

Technically, modu supports two alternate template engines in addition to Cheetah, but they have not been very thoroughly tested, and may lack features compared to the preferred Cheetah engine. These alternate template engines include CherryTemplate and ZPTPages, but it should be trivial to implement support for any template engine that can function with a namespace backed by a Python dictionary.

=== Standard Variables ===

The default TemplateContent superclass inserts a number of variables into the template dictionary as part of get_content(). Template engines that wish to use these variables must make sure to call the superclass get_content() from their own overridden version of the method.

The variables include:
    req
        The current request object.
    
    header_content
        During content generation, req.content.report('header', 'text') will accumulate a list of strings to be concatenated and inserted into this variable. It is currently used to allow code to insert STYLE, LINK, SCRIPT, or other tags into the HTML HEAD section. Since it uses the MessageQueue class to hold these items, duplicate calls to report() will be collapsed into a single entry. Unlike the usual req.messages queue, the content queue is not backed by the session, so data is not saved across requests.

These variables are set *after* prepare_content() is called, so it's important not to use these names for your own variables, since they will be clobbered.

=== Cheetah Revisions ===

First of all, it's important to understand Cheetah's origins, and that we are only using a subset of Cheetah's features. Cheetah integrates tightly with the Python web development toolkit Webware, and has a number of features that make sense in that environment, but that aren't terribly useful in the modu environment. It may be that some of these things *are*, in fact, useful to modu developers, but at this time they are unused.

Consequently, a few assumptions are made about how templates are used and organized in modu that may not be obvious to existing Cheetah users. The goal in this section is to outline some of these changes and development standards that have been adopted during use of Cheetah in the modu environment.

 * String Templates vs. Files
    As described in the Resource API section, templates can either be specified by returning a string template from get_template(), or by returning a filename (the interpretation of which is which is based on the result of get_template_type()).

 * Compiled templates
    When a template is new, it gets compiled to Python code, and that code gets saved in a file in the compiled_template_root directory. If the modified date of the template is newer than the compiled version, it is recompiled. One unfortunate implementation detail is that the compiled templates aren't loaded via the usual Python import mechanism, instead being read in and exec()ed. This will hopefully be addressed in the future.

 * Thread-safety
    Cheetah isn't entirely threadsafe, and we add some customizations that can potentially be an issue for threads, so the entire template compilation process is locked by semaphore. This could potentially have performance ramifications, but so far it seems to be relatively efficient.

 * Include files
    Include files are such a common template organization technique, some time was spent implementing these inside the modu environment. It's assumed that the location of the include files is the same as the calling template, but get_template_root() is still called for each. This allows particularly clever Resources (such as the AdminResource, which provides default templates for any that aren't overridden by the user) to alter the behavior of includes and template lookup in general.

 * Unicode support
    Release 2.2.0 of the Cheetah template software modified the template generation code to use entirely unicode strings. It then forced all strings in the template dictionary to be unicode as well. Since a large amount of modu code exists that depends on the ability to embed regular strings into templates, a monkeypatch exists to override the default behavior. This patch assumes that all bytestrings are encoded using UTF-8, and then decodes them to unicode objects before output. Finally, the get_content() method on a CheetahTemplateContent instance will convert back to UTF-8 before returning it to the user. At some point this code must be revised so that other encodings can be used.

== Forms ==

The modu Form API is a form generation tool that allows for a clean separation of form handling, rendering, and subsequent processing. It borrows heavily from the Drupal Form API, although obviously adapted to be more 'Pythonic'.

The premise of the design is based around building a form instance that describes the types of fields desired and their corresponding attributes. Validation and submission callback functions can be assigned to the form, and other methods are provided to load existing POST data into the form, or pass the form off to a theme object for rendering.

The Form API becomes even more important when working with the modu admin tool (aka the Editable API), as it provides the foundation of the itemdef configuration system.

=== NestedFieldStorage ===

The first essential aspect of the modu form-handling code is the use of a new class called NestedFieldStorage. This is a custom subclass of the standard Python library's cgi.FieldStorage object, and primarily allows for better organization of form data by enabling a hash-syntax-derived naming convention borrowed from PHP. For example, take the following POST data:

    field[123][name]    Phil
    field[124][email]   phil@example.com
    field[456][name]    Bill
    field[456][email]   bill@example.com

When submitted and parsed by the NestedFieldStorage class, the result is something like:

{{{
#!python
req.data = {
    'field' = {
        '123'       = {
            'name'      = cgi.MinifieldStorage('field[123][name]', 'Phil'),
            'email'     = cgi.MinifieldStorage('field[123]['email']', 'phil@example.com'),
        },
        '456'       = {
            'name'      = cgi.MinifieldStorage('field[456][name]', 'Bill'),
            'email'     = cgi.MinifieldStorage('field[456]['email']', 'bill@example.com'),
        },
    },
}
}}}

As indicated, this object is available through the 'modu.data' key in the Request dictionary, which is not populated until it is first requested.

One other major change to FieldStorage that NestedFieldStorage introduces is in the way it handles file uploads. The make_file() method of FieldStorage has been overridden to create SessionFile instances instead of tempfile.TemporaryFile. As the request is read, SessionFile updates session variables to include the progress of the uploaded file, to allow for client applications to show progress bars during upload.

Additional differences between NFS and the cgi.FieldStorage class include better truth value testing (e.g., a more properly defined __nonzero__), addition of a .get() function to better reflect its dict-like nature, and get_path(), which allows you to fetch an inner form value with a given array of path items.

=== Building Forms ===

Forms are built using nested instances of the FormNode class, which abstracts away rendering details to focus on field structure and processing. To increase readability of form definitions, a significant amount of syntactic sugar has been added to the process of creating forms. Here's an example of a basic address form:

{{{
#!python
address_form = form.FormNode('address-form')
address_form['name'](
    type        = 'textfield',
    label       = 'Name:',
    required    = True,
    size        = 30,
    maxlength   = 255,
)
address_form['address'](
    type        = 'textfield',
    label       = 'Street Address:',
    required    = True,
    size        = 30,
    maxlength   = 255,
)
address_form['city'](
    type        = 'textfield',
    label       = 'City:',
    required    = True,
    size        = 15,
    maxlength   = 255,
)
address_form['state'](
    type        = 'select',
    label       = 'State:',
    required    = True,
    options     = {'NY':'New York', 'CT':'Connecticut', ... },
)
}}}

At this point we have a nearly complete form object. One last thing we'll need to do is define validation and submission callback functions, and assign them to the form:

{{{
#!python
def _validate(req, frm):
    # a sample validation is defined on the form already, but
    # all it does is make sure 'required' fields have a value set.
    # we'll reuse this before doing our own validation
    if not(frm.default_validate(req, frm)):
        return False
    
    if(frm['state'].value != 'NY'):
        frm.set_error('state', "Sorry, New Yorkers only!")
        return False
    
    return True

address_form.validate = _validate
}}}

By the time the validation function is called, the form object will have been loaded with the POST data submitted in it, which is how we are able to do validation on the 'state' field. Technically, we could have omitted this step if all we wanted was to check for required fields.

The result of the validation function determines whether the form submission continues; if it returns False the submit function is not called. Here's a sample submit function:

{{{
#!python
def _submit(req, frm):
    f = open('userlist', 'w')
    f.write(frm['name'].value + "\n")
    f.write(frm['address'].value + "\n")
    f.write(frm['city'].value + "\n")
    f.write(frm['state'].value + "\n")
    f.close()
    return True
}}}

Submission functions can do pretty much anything, but you'll want to make sure to return a True value from submit. Whatever you return here will be returned by the execute() function (more on this in a moment), so it is possible to return some other value to be used by your form-dependent code.

=== Using Forms ===

Once a form is built, you are ready to 'execute' it, and finally render it. The usual process is something like:

{{{
#!python
def prepare_content(self, req):
    # assume this function returns the form we built above.
    address_form = self.get_address_form(req)
    
    # if the form failed validation or submission...
    if not(address_form.execute(req)):
        # ...place any errors in the global error queue
        address_form.escalate_errors(req)
    
    # render this form as HTML and include it in the template
    self.set_slot('address_form', address_form.render(req))
}}}

Calling the execute() method will load any available POST data into the form, and then check to see if any existing submit buttons were pressed. If so, then validation is attempted, which, if successful leads to the submit function.

Validation consists of calling the validate() function on the top-level form element. The default behavior is to check for required fields, as well as iterate through child elements calling their validate() methods (if available). If any of the validation methods return False, the entire form fails validation.

When errors occur during validation, user code should call set_error() to indicate which form element has an error. Calling escalate_errors() later on will copy those errors into req.messages as 'error' types, to be displayed at the developer's convenience.

Finally, regardless of the result of execute(), a rendered version of the form is created and included in the output (in this case, by adding it to the template). These examples are all (implicitly) using the default Theme class included with modu, but form elements may have their rendering customized by setting frm.theme at any element level.

=== Form Errors ===

Form errors are useful during validation. They allow code to indicate which form element contained a validation error, as well as include text describing the issue.

For simplicity, errors must always be set on a top-level element. Calling set_error() with a field name and error message will add it to the form node's internal list of errors.

Usually set_error() is used from within a validation function. For example, here's an implementation of the 'required field' validation process:

{{{
#!python
def _validate(self, req, form):
	result = True
	
	# if this is a child element
	if(self.parent or self.attributes.get('type', 'form') != 'form'):
		if(not self.attr('value', '') and self.attr('required', False)):
			form.set_error(self.name, 'You must enter a value for this field.')
			result = False
	
	# validate all children, if available
	for child in self:
		child = self[child]
		result = result and child.validate(req, form)
	
	return result
}}}

=== Themes ===

The rendering of form objects is based around Theme classes. This is another borrowed concept from the Drupal CMS, although for now it is specific to forms, unlike in Drupal, where it can render a wide variety of data structures.

Themes themselves are very simple, simply a class with a number of theme_* methods. When a form is rendered, the 'type' attribute is used to generate the theme method name, so a 'textarea' type form element will result in a call to theme_textarea().

This means that almost everything about the rendering of a form is left to the theme to decide. Form objects can include any number of arbitrary attributes, but Themes will only act on the attributes they understand.

Additionally, Themes are entirely responsible for handling the translation from a simple form object to a complex, possibly multi-value form element. This will be discussed further in Loading Form Data.

The form elements as rendered in the default theme class generally also have a number of common elements wrapped around them: a labeled DIV, applicable error info, the 'required' star, etc. These things are rendered by the theme_element() method. To enable this method to be reused in a suitably Pythonic way, form elements that want to be created with this "chrome" can use the @formelement decorator to automatically pass their output through the theme_element() function.

=== Loading Form Data ===

When the execute() method is called on a form, one thing that always happens is that any available POST data is loaded into the form object, setting the 'value' attribute on each applicable element. It uses the nested structure of the POST data as parsed by NestedFieldStorage to find the element within the form.

Note that this only works for element types that can correlate a single POST value with their data. For example:

{{{
#!python
form = FormNode('test-form')
form['time'](
    type    = 'time',
    value   = datetime.time.now(),
)
}}}

will render a multi-select date field with the current date and time. However, the resulting POST data will be:

    test-form[time][hour]       9
    test-form[time][minute]     19

There's a solution for this, which is to create a loader method in the Theme class.

=== Theme Loaders ===

To strict adherents of separation-of-concern, theme loaders may seem to violate the contract in some ways. Theme loaders are able to take a provided subset of POST data and use it to configure an element for display.

For example, in the 'time' example above, the resulting POST data would only load into the form object automatically if the form had been rendered literally; e.g., consisting of two nested select FormNodes for hour and minute respectively.

However, time fields are useful, so we don't want to always have to create those selects manually every time. Also, we don't want to lose the ability to change the actual display technique for all time fields by a change in the Theme. For example, we might want to use a javascript-enabled field that allows a user to move hands on a clock widget.

We create a theme loader by appending '_loader' to the theme method name. In this case, our theme method was called 'theme_time', so we'll create a theme loader called 'theme_time_loader':

{{{
#!python
def theme_time_loader(self, frm, data):
    import time
    v = ((int(data['hour'].value) * 60) + int(data['minute'].value)) * 60
    v += time.timezone
    frm(value=v)
}}}

The `data` variable is a subset of the full form data, only providing the variables under the 'test-form[time]' form path. More details could always be pulled from `self.req`, which is saved when the Theme is initially created.

== Storable API ==

The Storable API is a lightweight database access layer that is used in the modu toolkit. Although it was designed with SQL-based relational databases in mind, the mapping process is sufficiently flexible to allow use with any sort of data store.

Although it shares some features with some of the other myriad object-relational database mapping systems, there is very little "magic". Some conventions are encouraged, but few are required to use Storables, encouraging adaptation to existing schemas. For more complex data systems, custom Factory classes can be implemented to customize the manner in which new objects are instantiated.

=== Compatibility Note ===
At the time of this writing, modu's official database support is limited to MySQL. This document will unfortunately contain much MySQL-specific information, but in most cases attempts are made to use SQL standard syntax.

PostgreSQL has been tested with some success (there are existing Storable implementations for a number of popular Postgres DB-API 2.0 drivers), but there's still a existing MySQLdb dependency in [source:/trunk/modu/persist/sql.py].

=== IDs ===

Storable was based around a belief in using database-unique identifiers (the term "GUID" will be used even though it's not entirely accurate). Original reasons for use of GUIDs included support of multiple-master replication, but also to avoid reliance on database-specific sequences. Also, there is a default assumption that 'id' will be the name of the identity column, but both this and the use of GUIDs can be overridden at the factory level.

Note that at this time aggregate keys are not supported by DefaultFactory, but custom factory implementations should be able to fill the need until this capability can be integrated into the Storable API.

=== Getting Started ===

To begin, we'll define our schema. This will include a `guid` table, which for now will manage a single sequence.

{{{
#!sql
CREATE TABLE `guid` (
  `guid` bigint(20)
) ENGINE=MyISAM DEFAULT CHARACTER SET utf8;

CREATE TABLE `page` (
  `id` bigint(20),
  `url_code` varchar(255),
  `title` varchar(255),
  `data` LONGBLOB,
  `active` tinyint(1),
  PRIMARY KEY (`id`),
  UNIQUE KEY url_code_idx(`url_code`),
  KEY active_idx(`active`)
) ENGINE=MyISAM DEFAULT CHARACTER SET utf8;
}}}

Basic access to data like this is fairly straightforward. Here's a trivial example:

{{{
#!python
from modu.persist import dbapi, Store

db_url = 'MySQLdb://project:fh7fkW9s@localhost/project'
db_pool = dbapi.connect(db_url)
store = Store(db_pool)

store.ensure_factory('page')
page = store.load_one('page', url_code='home-page', active=1)

print 'ID#:   %s' % page.get_id()
print 'Title: %s' % page.title)
print page.data
}}}

=== Factories and You ===

The Storable API is an easily misunderstood framework. Because the default configuration of a freshly created Store object is geared only towards creating the simplest SQL queries, new users can read too far into the provided interface and assume that it's simply a code generation tool. The reality is that Storable provides a rich mechanism for loading database objects, but based around the idea that the developer knows best for a given project.

To better understand the API, it's important to understand the function and role of Storable Factories, and how they relate to the process of loading new content. First, let's look at a snippet of code from the above example:

{{{
#!python
store = Store(db_pool)
store.ensure_factory('page')
page = store.load_one('page', url_code='home-page', active=1)
}}}

The first line is straightforward, and is instantiating the ORM interface to the provided database. Until a factory is registered, the store has no ability to load anything from the database.

The second line is really the important one, although much of its meaning is abstracted away. It is identical in function to the following code:

{{{
#!python
from modu.persist import storable
page_factory = storable.DefaultFactory('page', model_class=storable.Storable, id_col='id', guid_table='guid', use_cache=None)
store.register_factory('page', page_factory)
}}}

The plain-English explanation is "when provided with the factory ID 'page', use the following Factory to create and update Storable objects that contain their primary key in a field called 'id', which pulls keys from the GUID table 'guid', and do not cache the results". The illustrated keyword arguments are defaults, so they could be safely omitted.

Using those defaults, the DefaultFactory class will create generic Storable objects from the rows of your result set. You can override the class used for the resulting objects by passing it as the `model_class` keyword argument. The provided class must be a subclass of Storable, however.

This brings us finally to the last important line:

{{{
#!python
page = store.load_one('page', url_code='home-page', active=1)
}}}

This call to load_one() will fetch the Factory associated with the factory ID 'page'. The resulting query that the factory builds will simply take the provided keyword arguments (or an optional positional argument containing a dictionary of column-value pairs), and build the simple query:

{{{
#!sql
SELECT * FROM `page` WHERE active = 1 AND url_code = 'home-page';
}}}

=== SQL Generation ===

Use of the store to load objects is encouraged (as opposed to using straight queries) because the persistence layer will take care of all query generation, ensuring protection from SQL injection attacks, and generally keeping the code more succinct and readable. Attempts are only made to deal with the simplest (and most common) queries, and the assumption is that advanced developers will want to write their own, but there's a good deal of power still available without writing queries.

modu uses an approach found in the MySQLdb driver (and probably others), which allows for customization of a list of types that can be interpolated into queries. The following examples illustrate the new interpolation options:

==== List Types ===
{{{
#!python
obj = store.load_one('table', id=(1,2,3,4))
}}}

{{{
#!sql
SELECT * FROM `table` WHERE id IN (1,2,3,4);
}}}

==== Inversion ===
{{{
#!python
from modu.persist import sql
obj = store.load_one('table', name=sql.NOT('phil'))
}}}

{{{
#!sql
SELECT * FROM `table` WHERE name <> 'phil';
}}}

{{{
#!python
from modu.persist import sql
obj = store.load_one('table', id=sql.NOT((1,2,3,4)))
}}}

{{{
#!sql
SELECT * FROM `table` WHERE id NOT IN (1,2,3,4);
}}}

==== Comparison ===
{{{
#!python
from modu.persist import sql
obj = store.load_one('table', id=sql.GT(1))
}}}

{{{
#!sql
SELECT * FROM `table` WHERE id > 1;
}}}

{{{
#!python
from modu.persist import sql
obj = store.load_one('table', id=sql.LT(1))
}}}

{{{
#!sql
SELECT * FROM `table` WHERE id < 1;
}}}

==== NULLs ===
{{{
#!python
obj = store.load_one('table', name=None)
}}}

{{{
#!sql
SELECT * FROM `table` WHERE ISNULL(name);
}}}

==== RAW SQL ===
{{{
#!python
from modu.persist import sql
obj = store.load_one('table', date=sql.RAW('NOW()'))
}}}

{{{
#!sql
SELECT * FROM `table` WHERE date = NOW();
}}}

{{{
#!python
from modu.persist import sql
obj = store.load_one('table', name=sql.RAW('INSTR(%s, "substring")'))
}}}

{{{
#!sql
SELECT * FROM `table` WHERE INSTR(name, "substring");
}}}

=== Custom Models ===

Storable diverts from the usual ORM requirement of creating custom model declarations for any table you wish to use. If you're just looking to load a record from the database, there's no need to configure a custom model. However, for any significant project, you'll want to create classes that adhere to the IStorable interface.

Unlike other ORMs, there's no requirement that you specify your schema inside the model class. Things by default work in a very database-centric fashion; if a column exists in the query, it will be available on an object loaded via that query.

You must also remember the following rules when creating a Storable model:

 1. All model classes must implement the IStorable interface. Most models can simply inherit from the base Storable class.
 2. The model constructor must not take any arguments, and it must call the superclass constructor with the table name being used.
 3. Any member variables that are not table column names should be prefixed with at least one underscore.

You have some control over how the object is instantiated by the Factory by way of the load_data() method. load_data() will be called with a single result row from the database; the default behavior is to set each column name as an instance attribute on the model class. Likewise, when saving the object back to the database, all instance attributes that do not begin with an underscore are saved to their corresponding columns. Instantiation control can be achieved through customization of these instance methods, but often times a better solution is creation of a new Factory class.

=== Paginator ===

The modu persistence layer comes with a utility class for dealing with paginating result sets. It's particularly useful when paging through a large number of simple queries, but also supports some advanced usage as well.

Basic usage is as follows:

{{{
#!python
from modu.persist import page, sql
from modu.util import theme

def prepare_content(self, req):
    pager = page.Paginator()
    
    # which page to fetch
    pager.page = int(req.data.get('page', '1'))
    # the default per_page is 10
    pager.per_page = 25
    
    # we still need to set up the factory
    req.store.ensure_factory('page')
    
    # get_results() takes care of adding the limit, and
    # getting the total (pre-limit) rowcount
    results = pager.get_results(req.store, 'page', date=sql.LT(sql.RAW('NOW()')))
    
    self.set_slot('results', results)
    
    # the default theme class can render a pager control
    base_path = req.get_path(req.path)
    thm = theme.Theme(req)
    page_guide = thm.page_guide(pager, base_path)
    self.set_slot('page_guide', page_guide)

}}}

== Admin Tool ==

modu comes with a configurable Resource implementation that provides an administrative interface for editing database data. Unlike the admin tools included with many other web frameworks, the modu admin requires a little more time up front for configuration, but in exchange provides a great deal of flexibility and customization.

The fundamental building-block of the admin is called an item definition, or 'itemdef'. An itemdef is a Python class that, like FormNodes, is used as a pseudo-DSL, to allow for an expressive configuration syntax. Once an itemdef is created, it can be used to generate forms for its various view modes.

The basic structure of the admin tool is split between 'list' and 'detail' modes. In list mode, users paginate through the rows of the table being managed, whereas detail view allows actual editing of the row in question (assuming you have the proper permissions).

=== What is an Itemdef? ===

An itemdef is a python object that can take a given Storable object and return a modu FormNode object with customized validation and submission functions already applied. The default submission process applies the modified data back to the Storable object and saves it to the database, while providing a number of optional callbacks, custom datatypes, and other conveniences that make building a custom admin tool a fairly straightforward process.

The conventional way to create itemdefs is to place the definition for each one inside its own Python module file. Here's an minimal example for a single-column `customer` table:

{{{
#!python
itemdef = define.itemdef(
    __config    = dict(
        name        = 'customer',
        label       = 'Customers',
    ),
    
    id          = string.LabelField(
        label       = 'ID:',
        listing     = True,
        weight      = 1,
    ),
    
    name        = string.StringField(
        label       = 'Name',
        listing     = True,
        weight      = 2,
    ),
)
}}}

This is fully valid Python, but it's presented here as a sort of domain-specific language, much like the FormNode class. Note that the result of the itemdef constructor is bound to a variable; the name of the variable doesn't matter, but the itemdef must be bound to some variable name to be found by the discovery process.

Also like FormNode, Request, and many other components of the modu APIs, it's a dict subclass. For the most part, it consists of a series of names mapped to the field type descriptors called 'definitions' or 'datatypes'.

Since Itemdefs share a common ancestry with FormNode objects, this has lead to a similarity between certain features. For example, like FormNode, additional elements can be added after instantiation:

{{{
#!python
itemdef['city']     = string.StringField(
    label   = 'City',
    listing = True
)

itemdef['state']    = string.SelectField(
    label   = 'State'
    options = {'AK':'Arkansas', 'AL':'Alabama', ... }
)
}}}

One thing that you should notice with as a difference between these two usage variations is that in the first example, we are required to provide 'weight' arguments to indicate the order of the fields. Since Python dictionaries don't preserve key order, and there's no way to override the type of object used to contain `**kwarg`-based arguments, this means a weight value must be provided.

In the second example, no weight argument is necessary, but may be used if desired.

=== Initial Configuration ===

The first step in enabling use of the admin tool is to activate it inside your modu site configuration. If you used mkmodu to create your project folder, the admin tool should already be enabled with a couple of basic itemdefs. Otherwise, you can add the admin Resource as follows:

{{{
#!python
    import myproject.itemdefs
    
	application.activate('/admin', resource.AdminResource,
	    default_path   = 'admin/listing/page', 
	    itemdef_module = myproject.itemdefs,
	)
}}}

The two keyword arguments specified here can be omitted, but are usually not. The first argument, 'default_path' specifies the modu path that should be automatically redirected to on login. If omitted, the use is simply taken to the first available itemdef; however, if they don't have access to that itemdef, an error will occur.

For more complex authentication scenarios, 'default_path' can be a function that takes the request object and returns some path, like this:

{{{
#!python
    def admin_path_callback(req):
        if(req.user.has_role('administrator')):
            return 'admin/listing/user'
        else:
            return 'admin/listing/page'
}}}

The `itemdef_module` keyword argument allows you to specify a python module/package to be scanned for itemdefs. This value can also be a sequence, allowing use of itemdefs from multiple packages.

=== Itemdef Development ===

Configuration options and variables can vary between different field types, but there are a number of standard configuration options that are applicable to every itemdef. They are specified by being included in the `__config` argument to the itemdef constructor, or by the `config` instance variable.

 '''name'''::
 '''Required'''::
    A unique identifier for this itemdef, usually the table name

 '''table'''::
 Default: `<table-name>`::
    If the identifier is not the table name, it must be set here

 '''label'''::
 Default: `<itemdef-name>`::
    The display name of this itemdef

 '''category'''::
 Default: `'other'`::
    The itemdef category

 '''weight'''::
 Default: `0`::
    The position of this itemdef in relation to others in its category

 '''acl'''::
 Default: `''`::
    The required user permission to use this itemdef. Can be provided as a single string permission required, or a list of required permissions.

 '''prewrite_callback'''::
 Default: `None`::
    Called during validation. If it returns False, validation will fail.

{{{
#!python
def prewrite_callback(req, form, storable):
    return True
}}}

 '''postwrite_callback'''::
 Default: `None`::
    Called during submit, after writing the storable. If it returns False, an error will be raised (but the main record will have already been written).

{{{
#!python
def postwrite_callback(req, form, storable):
    return True
}}}

 '''predelete_callback'''::
 Default: `None`::
    Called during validation. If it returns False, deletion will fail.

{{{
#!python
def predelete_callback(req, form, storable):
    return True
}}}

 '''postdelete_callback'''::
 Default: `None`::
    Called during submit, after deleting the storable.

{{{
#!python
def postdelete_callback(req, form, storable):
    pass
}}}

 '''theme'''::
 Default: `theme.Theme`::
    Called during submit, after deleting the storable.

 '''factory'''::
 Default: `storable.DefaultFactory`::
    Factory to use to build Storable objects.

 '''model_class'''::
 Default: `storable.Storable`::
    Model class to use with DefaultFactory.

 '''list_template'''::
 Default: `'admin-listing.tmpl.html'`::
    Overrides the default list template.

 '''detail_template'''::
 Default: `'admin-detail.tmpl.html'`::
    Overrides the default detail template.

 '''template_variable_callback'''::
 Default: `None`::
    A dict of name-value pairs returned from this function will be added to the template.

{{{
#!python
def template_variable_callback(req, form, storable):
    return {'myvariable':'myvalue'}
}}}

 '''title_column'''::
 Default: `'title'`::
    The name of a result column that should be used as the title.

 '''no_create'''::
 Default: `False`::
    Disable creation for this itemdef.

 '''per_page'''::
 Default: `25`::
    The number of results to show per listing page.

 '''listing_title'''::
 Default: `'Listing <Name> Records'`::
    The title to be displayed on listing pages.

 '''export_query_builder'''::
 Default: `None`::
    When using the export feature, this function will be called to generate the query.

{{{
#!python
def export_query_builder(req, itemdef, attribs):
	return sql.build_select(itemdef.name, attribs)
}}}

 '''export_type'''::
 Default: `'csv'`::
    Export type (may be 'csv' or 'tsv').

 '''export_le'''::
 Default: `'\n'`::
    Line endings to use in exported CSV.

 '''export_formatter'''::
 Default: `None`::
    When using the export feature, this function will be called to generate the query.

{{{
#!python
def export_formatter(req, itemdef, item):
	# Use m.u.OrderedDict to enforce column order
	return dict()
}}}

 '''export_callback'''::
 Default: `None`::
    When using the export feature, this function will be called after the result rows have been fetched.

{{{
#!python
def export_callback(req):
	pass
}}}

 '''resource'''::
 Default: `None`::
    If `resource` is defined, this resource will provide the content for this itemdef while most other itemdef configuration variables (and any defined fields) will be ignored.
